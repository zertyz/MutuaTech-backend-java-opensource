package mutua.p2pcommunications;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import mutua.p2pcommunications.model.P2PServicesAPIMethodCallInfo;

/** <pre>
 * P2PServicesAPI.java
 * ===================
 * (created by luiz, Dec 20, 2014)
 *
 * Defines the base class for all P2PServicesAPI as well as methods that allow general method invocations
 *
 * @see RelatedClass(es)
 * @version $Id$
 * @author luiz
 */

public abstract class P2PServicesAPI {

	public static String P2PServiceAndVersionId;
	
	protected static int DEFAULT_MS_TIMEOUT_FOR_QUEUE_OFFERING_OPERATIONS = 1000;
	protected static int DEFAULT_MS_TIMEOUT_FOR_QUEUE_POLLING_OPERATIONS = 1000;
	
	private Class<? extends P2PServicesAPI> r = this.getClass();
	private ArrayBlockingQueue<P2PServicesAPIMethodCallInfo> pendingP2PServicesAPIRequests = new ArrayBlockingQueue<P2PServicesAPIMethodCallInfo>(1, true);
	
	private Object[] attemptToMatchAndCapture(String input, String regularExpression) {
        Pattern pattern = Pattern.compile(regularExpression, Pattern.DOTALL | Pattern.MULTILINE);
        Matcher m = pattern.matcher(input);
        while (m.find()) {
            Object[] captures = new String[m.groupCount()];
            if (m.groupCount() > 0) {
                for (int i=0; i<captures.length; i++) {
                    captures[i] = m.group(i+1);                // discard item 0 -- the matched string
                }
            }
            //String matched = m.group();
            return captures;
        }
        return null;
	}
	
	public P2PServicesAPIMethodCallInfo parseProtocolMessageIntoMethodCall(String protocolMessage) {
		Method[] methods = r.getMethods();
		for (Method method : methods) {
			if (method.isAnnotationPresent(RecognizePattern.class)) {
				String recognizePattern = method.getAnnotation(RecognizePattern.class).value();
				Object[] parameters = attemptToMatchAndCapture(protocolMessage, recognizePattern);
				if (parameters != null) {
					return new P2PServicesAPIMethodCallInfo(method, parameters);
				}
			}
		}
		return null;
	}
	
	/** Returns the 'P2PServicesAPIMethodCallInfo' for the given parameters */
	public P2PServicesAPIMethodCallInfo getAPIMethodInvocationInfo(String methodName, Object... parameters) throws NoSuchMethodException {
		// get the method to call
		Class<?>[] parameterTypes = new Class<?>[parameters.length];
		for (int i=0; i<parameters.length; i++) {
			parameterTypes[i] = parameters[i].getClass();
		}
		Method method = r.getMethod(methodName, parameterTypes);
		// build the invocation data
		P2PServicesAPIMethodCallInfo methodCallInfo = new P2PServicesAPIMethodCallInfo(method, parameters);
		return methodCallInfo;
	}

	/** Adds to the pending queue a method invocation, returning false if the queue is full and no call was added */
	public boolean scheduleAsynchronousRequestAnsweringMethodForExecution(P2PServicesAPIMethodCallInfo methodCallInfo) {
		// attempt to add to the queue
		try {
			return pendingP2PServicesAPIRequests.offer(methodCallInfo, DEFAULT_MS_TIMEOUT_FOR_QUEUE_OFFERING_OPERATIONS, TimeUnit.MILLISECONDS);
		} catch (InterruptedException e) {
			return false;
		}
	}
	
	public String executeNextScheduledAsynchronousRequestAnsweringMethod() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, InterruptedException {
		P2PServicesAPIMethodCallInfo methodCallInfo = pendingP2PServicesAPIRequests.poll(DEFAULT_MS_TIMEOUT_FOR_QUEUE_POLLING_OPERATIONS, TimeUnit.MILLISECONDS);
		return ivokeAsynchronousRequestAnsweringMethod(methodCallInfo);
	}

	/** Invokes a request method annotated with 'P2PServicesAPIRequestingMethod', returning the protocol message generated by it */
	public String invokeRequestMethod(P2PServicesAPIMethodCallInfo methodCallInfo) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		String answer = (String)methodCallInfo.getMethod().invoke(this, methodCallInfo.getParameters());
		return answer;
	}

	/** Invokes methods annotated with 'P2PServicesAPIAsynchronousRequestReceiverMethod' */
	public P2PServicesAPIMethodCallInfo invokeAsynchronousRequestReceiverMethod(P2PServicesAPIMethodCallInfo methodCallInfo) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		P2PServicesAPIMethodCallInfo answer = (P2PServicesAPIMethodCallInfo)methodCallInfo.getMethod().invoke(this, methodCallInfo.getParameters());
		return answer;
	}

	/** Invokes methods annotated with 'P2PServicesAPIAsynchronousRequestAnsweringMethod' */
	public String ivokeAsynchronousRequestAnsweringMethod(P2PServicesAPIMethodCallInfo methodCallInfo) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		String answer = (String)methodCallInfo.getMethod().invoke(this, methodCallInfo.getParameters());
		return answer;
	}
	
	/** Invokes methods annotated with 'P2PServicesAPIAnswerReceiverMethod' */
	public boolean invokeAnswerReceiverMethod(P2PServicesAPIMethodCallInfo methodCallInfo) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		boolean ack = (Boolean)methodCallInfo.getMethod().invoke(this, methodCallInfo.getParameters());
		return ack;
	}

}
